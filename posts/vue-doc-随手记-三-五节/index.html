<!DOCTYPE html>
<html lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="" />
	
	
	
	<title>Vue Doc 随手记 ——三-五节 ｜ likon</title>
	
    
    
    <meta name="description" content="官方文档随手记" />
    

    
    
    <meta name="keywords" content="likon, 碎碎念, 记录" />
    

	
    
    <link rel="shortcut icon" href="https://likontech.github.io/images/favicon.ico" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://likontech.github.io/css/normalize.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://likontech.github.io/css/fonts.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://likontech.github.io/css/zozo.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/remixicon@3.4.0/fonts/remixicon.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://likontech.github.io/css/highlight.css" />

    
    <meta name="baidu-site-verification" content="codeva-8R2pKP1np7" /><meta name="google-site-verification" content="ygQ8KQgcIWSof2ZwcTWHsY7J0FEV5LF6uxVybFBHEBc" />

    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <meta name="referrer" content="no-referrer-when-downgrade"></head>

<body>
    <div class="main animate__animated animate__fadeInDown">
        <div class="nav_container animated fadeInDown">
    <div class="site_nav" id="site_nav">
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/posts/">Archive</a>
            </li>
            
            <li>
                <a href="/tags/">Tags</a>
            </li>
            
            <li>
                <a href="/about/">About</a>
            </li>
            
        </ul>
    </div>
    <div class="menu_icon">
        <a id="menu_icon"><i class="ri-menu-line"></i></a>
    </div>
</div>
        <div class="header animated fadeInDown">
    <div class="site_title_container">
        <div class="site_title">
            <h1>
                <a href="https://likontech.github.io/">
                    <img class="likon" style="margin-top: -20px; margin-left: -10px;" src="https://likontech.github.io/images/icon_likon.png" width="150px">
                    
                </a>
            </h1>
        </div>
        <div class="description">
            <p class="sub_title">岁岁年，碎碎念</p>
            <div class="my_socials">
                
                <a href="https://github.com/likontech" title="github" target="_blank"><i class="ri-github-fill"></i></a>
                
                <a href="https://twitter.com/likontech" title="twitter" target="_blank"><i class="ri-twitter-fill"></i></a>
                
                <a href="https://likontech.github.io/index.xml" type="application/rss+xml" title="rss" target="_blank"><i
                        class="ri-rss-fill"></i></a>
            </div>
        </div>
    </div>
</div>
        <div class="content">
            <div class="post_page">
                <div class="post animate__animated animate__fadeInDown">
                    <div class="post_title post_detail_title">
                        <h2><a href='/posts/vue-doc-%E9%9A%8F%E6%89%8B%E8%AE%B0-%E4%B8%89-%E4%BA%94%E8%8A%82/'>Vue Doc 随手记 ——三-五节</a></h2>
                        <span class="date"><i class="ri-calendar-fill"> </i>2023.08.02</span>
                        <span>&nbsp;</span>
                        
                        
                            <span class="date" id="busuanzi_container_page_pv">
                                <i class="ri-eye-fill"> </i><span class="date" id="busuanzi_value_page_pv"></span>
                            </span>
                        <span>&nbsp;</span>
                        <span class="date"><i class="ri-quill-pen-fill"> </i>967</span>
                    </div>
<aside>
    <nav id="TableOfContents">
  <ul>
    <li><a href="#响应式基础">响应式基础</a>
      <ul>
        <li><a href="#ref">ref</a></li>
        <li><a href="#reactive">reactive</a></li>
      </ul>
    </li>
    <li><a href="#计算属性">计算属性</a>
      <ul>
        <li><a href="#可写计算属性writable-computed-properties">可写计算属性（Writable Computed Properties）</a></li>
        <li><a href="#计算属性最佳实践">计算属性最佳实践​</a></li>
      </ul>
    </li>
    <li><a href="#class-与-style-绑定">Class 与 Style 绑定</a>
      <ul>
        <li><a href="#绑定-html-class">绑定 HTML class</a></li>
        <li><a href="#绑定内联样式">绑定内联样式</a></li>
      </ul>
    </li>
  </ul>
</nav>
</aside>





                    <div class="post_content markdown"><blockquote>
<p>室温超导体新闻这两天热火朝天。</p>
<p>室温超导体是指在常规的室温条件下（通常是接近或等于常温，即约 20 摄氏度）能够表现出超导现象的材料。超导现象是指在某些材料中，在特定的低温条件下，电阻突然变为零，并且磁场被完全排斥的现象。传统的超导材料需要极低的温度（接近绝对零度，约 -273.15 摄氏度）才能表现出超导行为，这对于应用和实际应用来说非常不便。</p>
</blockquote>
<h1 id="三-五节">三-五节</h1>
<ol>
<li>响应式基础</li>
<li>计算属性</li>
<li>Class 与 Style 绑定</li>
</ol>
<h2 id="响应式基础">响应式基础</h2>
<h3 id="ref">ref</h3>
<pre tabindex="0"><code>import { ref } from &#39;vue&#39;

export default {
  setup() {
    const count = ref(0)

    function increment() {
      // 在 JavaScript 中需要 .value
      count.value++
    }

    // 不要忘记同时暴露 increment 函数
    return {
      count,
      increment
    }
  }
}

&lt;button @click=&#34;increment&#34;&gt;
  {{ count }}
&lt;/button&gt;
</code></pre><p>在 setup() 函数中手动暴露大量的状态和方法非常繁琐。可以通过使用单文件组件 (SFC) 来避免这种情况。可以使用 &lt;script setup&gt; 简化代码。</p>
<pre tabindex="0"><code>&lt;script setup&gt;
import { ref } from &#39;vue&#39;

const count = ref(0)

function increment() {
  count.value++
}
&lt;/script&gt;

&lt;template&gt;
  &lt;button @click=&#34;increment&#34;&gt;
    {{ count }}
  &lt;/button&gt;
&lt;/template&gt;
</code></pre><p>为什么需要 ref？</p>
<p>使用 ref 可以将普通的 JavaScript 数据转换为 Vue.js 中的响应式数据，从而保证数据的更新能够正确地触发视图的更新，并方便地在组件中访问和修改数据。</p>
<pre tabindex="0"><code>// 伪代码，不是真正的实现，类似 iOS 的 KVO 的实现
const myRef = {
  _value: 0,
  get value() {
    track()
    return this._value
  },
  set value(newValue) {
    this._value = newValue
    trigger()
  }
}
</code></pre><blockquote>
<p>DOM 更新时机：当你修改了响应式状态时，DOM 会被自动更新。
注意，DOM 更新不是同步的。Vue 会在“next tick”更新周期中缓冲所有状态的修改，以确保不管你进行了多少次状态修改，每个组件都只会被更新一次。</p>
<p>要等待 DOM 更新完成后再执行额外的代码，可以使用 nextTick() 全局 API：</p>
<pre tabindex="0"><code>import { nextTick } from &#39;vue&#39;
async function increment() {
  count.value++
  await nextTick()
  // 现在 DOM 已经更新了
}
</code></pre></blockquote>
<h3 id="reactive">reactive</h3>
<p>reactive() 将使对象本身具有响应性</p>
<p>响应式对象是 JavaScript 代理，其行为就和普通对象一样。不同的是，Vue 能够拦截对响应式对象所有属性的访问和修改，以便进行依赖追踪和触发更新。</p>
<blockquote>
<p>JavaScript 代理（Proxy）是 ES6（ECMAScript 2015）引入的一种特性，它允许你创建一个代理对象，用于拦截对目标对象的访问和操作。代理对象可以完全自定义目标对象的行为，并提供了一种强大的机制来拦截和定制对象的操作。</p>
<p>代理对象是由 <code>Proxy</code> 构造函数创建的，它接受两个参数：目标对象（target）和一个处理程序对象（handler）。目标对象是被代理的对象，而处理程序对象包含了一组拦截器（handler traps），这些拦截器用于拦截对目标对象的各种操作。</p>
<p>代理对象拦截了对目标对象的各种操作，包括属性访问、属性赋值、函数调用、对象的拷贝等。你可以通过在处理程序对象中提供对应的拦截器来定制代理对象的行为。</p>
<p>下面是一个简单的示例，展示了如何创建一个代理对象：</p>
<pre tabindex="0"><code>// 目标对象
const targetObject = {
  name: &#39;John&#39;,
  age: 30,
};

// 处理程序对象
const handler = {
  get: function(target, prop) {
    console.log(`Getting property &#34;${prop}&#34;`);
    return target[prop];
  },
  set: function(target, prop, value) {
    console.log(`Setting property &#34;${prop}&#34; to &#34;${value}&#34;`);
    target[prop] = value;
  },
};

// 创建代理对象
const proxyObject = new Proxy(targetObject, handler);

// 使用代理对象
proxyObject.name; // Output: Getting property &#34;name&#34;, Result: &#34;John&#34;
proxyObject.age = 35; // Output: Setting property &#34;age&#34; to &#34;35&#34;
</code></pre><p>在上面的示例中，我们创建了一个代理对象 <code>proxyObject</code>，它代理了目标对象 <code>targetObject</code>。在处理程序对象 &gt;<code>handler</code> 中，我们定义了 <code>get</code> 和 <code>set</code> 拦截器，用于拦截对属性的访问和赋值操作。</p>
<p>当我们访问代理对象的属性时，拦截器中的 <code>get</code> 方法会被调用，并输出相应的日志。当我们对代理对象的属性进行赋值时，拦截器中的 <code>set</code> 方法会被调用，并输出相应的日志。</p>
<p>代理对象的强大之处在于，你可以在拦截器中实现自定义的逻辑，从而实现更高级的功能，比如数据验证、缓存、日志记录等。代理是 JavaScript 中一种非常有用的特性，它在实际开发中常用于构建拦截器、数据绑定和数据监听等功能。</p>
</blockquote>
<p>ref 和 reactive 区别是什么？</p>
<p>在 Vue.js 3.x 中，<code>ref</code> 和 <code>reactive</code> 是两种不同的方法用于声明响应式数据，它们之间有一些区别：</p>
<ol>
<li><strong>数据结构</strong>：</li>
</ol>
<ul>
<li>
<p><code>ref</code>：<code>ref</code> 函数用于将普通的 JavaScript 值转换为一个响应式对象。<code>ref</code> 函数将传入的值包装在一个特殊的对象中，并返回这个对象。当你在模板中使用 <code>ref</code> 声明的数据时，不需要使用 <code>.value</code>，Vue.js 会自动进行解包。</p>
</li>
<li>
<p><code>reactive</code>：<code>reactive</code> 函数用于将普通的 JavaScript 对象转换为一个响应式对象。<code>reactive</code> 函数返回一个代理对象，可以拦截对目标对象的访问和操作。当你在模板中使用 <code>reactive</code> 声明的数据时，需要使用 <code>.value</code> 来解包。</p>
</li>
</ul>
<ol start="2">
<li><strong>使用方式</strong>：</li>
</ol>
<ul>
<li><code>ref</code>：通常用于声明基本类型的响应式数据，例如数字、字符串等。</li>
</ul>
<pre tabindex="0"><code>import { ref } from &#39;vue&#39;;

const count = ref(0); // 声明响应式数字
const message = ref(&#39;Hello&#39;); // 声明响应式字符串
</code></pre><ul>
<li><code>reactive</code>：通常用于声明复杂类型的响应式数据，例如对象和数组。</li>
</ul>
<pre tabindex="0"><code>import { reactive } from &#39;vue&#39;;

const user = reactive({ name: &#39;John&#39;, age: 30 }); // 声明响应式对象
const list = reactive([1, 2, 3]); // 声明响应式数组
</code></pre><ol start="3">
<li><strong>访问方式</strong>：</li>
</ol>
<ul>
<li><code>ref</code>：在模板中访问 <code>ref</code> 声明的数据时，不需要使用 <code>.value</code>，Vue.js 会自动进行解包。</li>
</ul>
<pre tabindex="0"><code>&lt;!-- 在模板中直接使用 ref 声明的数据 --&gt;
&lt;p&gt;{{ count }}&lt;/p&gt;
&lt;button @click=&#34;count++&#34;&gt;Increment&lt;/button&gt;
</code></pre><ul>
<li><code>reactive</code>：在模板中访问 <code>reactive</code> 声明的数据时，需要使用 <code>.value</code> 来解包。</li>
</ul>
<pre tabindex="0"><code>&lt;!-- 在模板中使用 reactive 声明的数据需要使用 .value 进行解包 --&gt;
&lt;p&gt;{{ user.name }}&lt;/p&gt;
&lt;button @click=&#34;user.age++&#34;&gt;Increment Age&lt;/button&gt;
</code></pre><ol start="4">
<li><strong>实现原理</strong>：
ref 和 reactive 都使用了 ES6 的 Proxy 对象来实现响应式数据，区别在于 ref 包装的是基本类型的值并使用了特殊的 Ref 类型对象，而 reactive 则直接创建一个普通对象的代理。</li>
</ol>
<p>总结：<code>ref</code> 和 <code>reactive</code> 都用于声明响应式数据，<code>ref</code> 适用于简单类型的数据，而 <code>reactive</code> 适用于复杂类型的数据。在模板中使用 <code>ref</code> 声明的数据时，不需要使用 <code>.value</code> 进行解包，而在使用 <code>reactive</code> 声明的数据时，需要使用 <code>.value</code> 进行解包。</p>
<p>Reactive Proxy vs. Original</p>
<pre tabindex="0"><code>const raw = {}
const proxy = reactive(raw)
// 代理对象和原始对象不是全等的
console.log(proxy === raw) // false

// 在同一个对象上调用 reactive() 会返回相同的代理
console.log(reactive(raw) === proxy) // true
// 在一个代理上调用 reactive() 会返回它自己
console.log(reactive(proxy) === proxy) // true

const proxy = reactive({})
const raw = {}
proxy.nested = raw
// 响应式对象内的嵌套对象依然是代理
console.log(proxy.nested === raw) // false
</code></pre><h2 id="计算属性">计算属性</h2>
<p>计算属性（Computed Properties）主要用于两个问题：</p>
<ol>
<li>
<p><strong>复杂逻辑的封装</strong>：当在模板中需要根据一些数据的状态或属性进行复杂的计算时，直接在模板中写这些计算逻辑会导致模板变得复杂难以维护。使用计算属性可以将这些复杂的计算逻辑封装在一个函数中，让模板保持简洁和易读。</p>
</li>
<li>
<p><strong>缓存计算结果</strong>：计算属性会对其依赖的响应式数据进行追踪，只有当依赖的数据发生变化时，计算属性才会重新计算。这意味着计算属性的结果会被缓存，如果依赖的数据没有发生变化，计算属性不会重新执行计算，而是直接返回缓存的结果。这样可以避免不必要的计算，提高性能。</p>
</li>
</ol>
<p>下面是一个示例来展示计算属性的用法和好处：</p>
<pre tabindex="0"><code>&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;Total Price: {{ totalPrice }}&lt;/p&gt;
    &lt;p&gt;Discounted Price: {{ discountedPrice }}&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import { ref, computed } from &#39;vue&#39;;

export default {
  setup() {
    const quantity = ref(5);
    const price = ref(10);
    const discount = ref(0.1);

    // 计算属性 totalPrice
    const totalPrice = computed(() =&gt; quantity.value * price.value);

    // 计算属性 discountedPrice
    const discountedPrice = computed(() =&gt; totalPrice.value * (1 - discount.value));

    return {
      quantity,
      price,
      discount,
      totalPrice,
      discountedPrice,
    };
  },
};
&lt;/script&gt;
</code></pre><p>在上面的示例中，我们使用计算属性 <code>totalPrice</code> 和 <code>discountedPrice</code> 来计算总价和折扣后的价格。计算属性 <code>totalPrice</code> 依赖于 <code>quantity</code> 和 <code>price</code>，而 <code>discountedPrice</code> 依赖于 <code>totalPrice</code> 和 <code>discount</code>。当 <code>quantity</code>、<code>price</code> 或 <code>discount</code> 发生变化时，计算属性会重新计算并更新视图。而如果这些依赖没有变化，计算属性会返回之前缓存的计算结果，避免重复计算。</p>
<p>通过使用计算属性，你可以将复杂的计算逻辑封装在一个地方，使模板保持简洁和可读性，并通过缓存计算结果提高性能。这使得你的代码更易于维护和优化。</p>
<h3 id="可写计算属性writable-computed-properties">可写计算属性（Writable Computed Properties）</h3>
<pre tabindex="0"><code>&lt;template&gt;
  &lt;div&gt;
    &lt;input v-model=&#34;fullName&#34; /&gt;
    &lt;p&gt;First Name: {{ firstName }}&lt;/p&gt;
    &lt;p&gt;Last Name: {{ lastName }}&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import { ref, computed } from &#39;vue&#39;;

export default {
  setup() {
    const fullName = ref(&#39;&#39;);
    
    // 可写计算属性
    const firstName = computed({
      get: () =&gt; fullName.value.split(&#39; &#39;)[0],
      set: (value) =&gt; {
        const lastName = fullName.value.split(&#39; &#39;)[1];
        fullName.value = value + &#39; &#39; + lastName;
      },
    });

    const lastName = computed(() =&gt; fullName.value.split(&#39; &#39;)[1]);

    return {
      fullName,
      firstName,
      lastName,
    };
  },
};
&lt;/script&gt;
</code></pre><h3 id="计算属性最佳实践">计算属性最佳实践​</h3>
<ol>
<li>
<p>Getter 不应有副作用​</p>
<p>计算属性的 getter 应只做计算而没有任何其他的副作用，这一点非常重要，请务必牢记。举例来说，不要在 getter 中做异步请求或者更改 DOM！一个计算属性的声明中描述的是如何根据其他值派生一个值。因此 getter 的职责应该仅为计算和返回该值。在之后的指引中我们会讨论如何使用侦听器根据其他响应式状态的变更来创建副作用。</p>
</li>
<li>
<p>避免直接修改计算属性值​</p>
<p>从计算属性返回的值是派生状态。可以把它看作是一个“临时快照”，每当源状态发生变化时，就会创建一个新的快照。更改快照是没有意义的，因此计算属性的返回值应该被视为只读的，并且永远不应该被更改——应该更新它所依赖的源状态以触发新的计算。</p>
</li>
</ol>
<h2 id="class-与-style-绑定">Class 与 Style 绑定</h2>
<p>Vue 专门为 class 和 style 的 v-bind 用法提供了特殊的功能增强。除了字符串外，表达式的值也可以是对象或数组。</p>
<h3 id="绑定-html-class">绑定 HTML class</h3>
<p>绑定对象</p>
<pre tabindex="0"><code>&lt;div :class=&#34;{ active: isActive }&#34;&gt;&lt;/div&gt;

const isActive = ref(true)
const hasError = ref(false)
&lt;div
  class=&#34;static&#34;
  :class=&#34;{ active: isActive, &#39;text-danger&#39;: hasError }&#34;
&gt;&lt;/div&gt;
# 渲染结果为
&lt;div class=&#34;static active&#34;&gt;&lt;/div&gt;

# 直接绑定一个对象
const classObject = reactive({
  active: true,
  &#39;text-danger&#39;: false
})
&lt;div :class=&#34;classObject&#34;&gt;&lt;/div&gt;

# 绑定一个返回对象的计算属性
const isActive = ref(true)
const error = ref(null)

const classObject = computed(() =&gt; ({
  active: isActive.value &amp;&amp; !error.value,
  &#39;text-danger&#39;: error.value &amp;&amp; error.value.type === &#39;fatal&#39;
}))
&lt;div :class=&#34;classObject&#34;&gt;&lt;/div&gt;
</code></pre><p>绑定数组</p>
<pre tabindex="0"><code>const activeClass = ref(&#39;active&#39;)
const errorClass = ref(&#39;text-danger&#39;)
&lt;div :class=&#34;[activeClass, errorClass]&#34;&gt;&lt;/div&gt;

# 三元表达式
&lt;div :class=&#34;[isActive ? activeClass : &#39;&#39;, errorClass]&#34;&gt;&lt;/div&gt;

&lt;div :class=&#34;[{ active: isActive }, errorClass]&#34;&gt;&lt;/div&gt;
</code></pre><p>在组件上使用</p>
<p>对于只有一个根元素的组件，当你使用了 class attribute 时，这些 class 会被添加到根元素上并与该元素上已有的 class 合并。</p>
<pre tabindex="0"><code>&lt;!-- 子组件模板 --&gt;
&lt;p class=&#34;foo bar&#34;&gt;Hi!&lt;/p&gt;

&lt;!-- 在使用组件时 --&gt;
&lt;MyComponent class=&#34;baz boo&#34; /&gt;

# 渲染出的 HTML 为：
&lt;p class=&#34;foo bar baz boo&#34;&gt;Hi!&lt;/p&gt;
</code></pre><p>Class 的绑定也是同样的：</p>
<pre tabindex="0"><code>&lt;MyComponent :class=&#34;{ active: isActive }&#34; /&gt;

&lt;p class=&#34;foo bar active&#34;&gt;Hi!&lt;/p&gt;
</code></pre><p>如果你的组件有多个根元素，你将需要指定哪个根元素来接收这个 class。你可以通过组件的 $attrs 属性来实现指定：</p>
<pre tabindex="0"><code>&lt;!-- MyComponent 模板使用 $attrs 时 --&gt;
&lt;p :class=&#34;$attrs.class&#34;&gt;Hi!&lt;/p&gt;
&lt;span&gt;This is a child component&lt;/span&gt;

&lt;MyComponent class=&#34;baz&#34; /&gt;

# 渲染出的 HTML 为：
&lt;p class=&#34;baz&#34;&gt;Hi!&lt;/p&gt;
&lt;span&gt;This is a child component&lt;/span&gt;
</code></pre><h3 id="绑定内联样式">绑定内联样式</h3>
<p>绑定对象</p>
<pre tabindex="0"><code>const activeColor = ref(&#39;red&#39;)
const fontSize = ref(30)
# camelCase
&lt;div :style=&#34;{ color: activeColor, fontSize: fontSize + &#39;px&#39; }&#34;&gt;&lt;/div&gt;

# kebab-cased
&lt;div :style=&#34;{ &#39;font-size&#39;: fontSize + &#39;px&#39; }&#34;&gt;&lt;/div&gt;


const styleObject = reactive({
  color: &#39;red&#39;,
  fontSize: &#39;13px&#39;
})
&lt;div :style=&#34;styleObject&#34;&gt;&lt;/div&gt;
</code></pre><p>绑定数组</p>
<pre tabindex="0"><code>&lt;div :style=&#34;[baseStyles, overridingStyles]&#34;&gt;&lt;/div&gt;
</code></pre><p>自动前缀</p>
<p>当你在 :style 中使用了需要浏览器特殊前缀的 CSS 属性时，Vue 会自动为他们加上相应的前缀。Vue 是在运行时检查该属性是否支持在当前浏览器中使用。如果浏览器不支持某个属性，那么将尝试加上各个浏览器特殊前缀，以找到哪一个是被支持的。</p>
<blockquote>
<p>什么是浏览器特殊前缀</p>
<p>浏览器特殊前缀（Browser Vendor Prefix），也称为私有前缀（Private Prefix），是一种在 CSS 属性名称前面添加特定浏览器厂商前缀的技术。这些前缀用于在浏览器支持某些实验性或尚未正式纳入 CSS 规范的 CSS 属性时进行区分，以便开发者能够在不同浏览器中实验和应用新的 CSS 特性。</p>
<p>由于 CSS 规范在发展过程中，一些新特性可能尚未得到所有浏览器的广泛支持，或者不同浏览器对同一属性的实现方式可能存在差异。为了解决这些问题，浏览器厂商（如Chrome、Firefox、Safari、Edge等）会在实验性或尚未稳定的 CSS 属性名称前添加特定的前缀，以区分不同浏览器的实现。</p>
<p>常见的浏览器特殊前缀包括：</p>
<ul>
<li><code>-webkit-</code>：用于 Safari 和 Chrome 浏览器。</li>
<li><code>-moz-</code>：用于 Firefox 浏览器。</li>
<li><code>-ms-</code>：用于 Microsoft Edge 浏览器。</li>
<li><code>-o-</code>：用于 Opera 浏览器。</li>
</ul>
<p>例如，<code>-webkit-border-radius</code> 是 Safari 和 Chrome 中用于设置元素边框圆角的属性，而 <code>-moz-border-radius</code> 则是 Firefox 中的对应属性。在这种情况下，开发者需要使用多个前缀来支持不同浏览器，例如：</p>
<pre tabindex="0"><code>.my-element {
  -webkit-border-radius: 10px;
  -moz-border-radius: 10px;
  border-radius: 10px;
}
</code></pre><p>然而，随着 CSS 规范的不断发展和浏览器对新特性的支持日益完善，许多实验性属性已经得到了标准化，并且浏览器厂商逐渐减少了对特殊前缀的依赖。现在在使用 CSS 属性时，通常只需要写标准的属性名即可，而无需添加浏览器特殊前缀。不过，在开发过程中，为了确保网站的兼容性，仍然建议使用 CSS 厂商前缀进行一定程度的属性设置。</p>
</blockquote>
<p>样式多值</p>
<p>对一个样式属性提供多个 (不同前缀的) 值</p>
<pre tabindex="0"><code>&lt;div :style=&#34;{ display: [&#39;-webkit-box&#39;, &#39;-ms-flexbox&#39;, &#39;flex&#39;] }&#34;&gt;&lt;/div&gt;
</code></pre><p>数组仅会渲染浏览器支持的最后一个值。在这个示例中，在支持不需要特别前缀的浏览器中都会渲染为 display: flex。</p>
</div>
                    <div class="post_footer">
                        
                        <div class="meta">
                            <div class="info">
                                <span class="field tags">
                                    <i class="ri-stack-line"></i>
                                    
                                    <a href="https://likontech.github.io/tags/vue/">vue</a>
                                    
                                </span>
                            </div>
                        </div>
                        
                    </div>
                </div>
                <img class="likon" style="margin-top: 20px; margin-left: -30px;" src="https://likontech.github.io/images/icon_wechat.png" width="200px">
                
                

    <script src="https://utteranc.es/client.js"
        repo="likontech/likontech.github.io"
        issue-term="title"
        label="碎碎念"
        theme="github-light"
        crossorigin="anonymous"
        async>
    </script>    

            </div>
        </div>
    </div>
    <a id="back_to_top" href="#" class="back_to_top"><i class="ri-arrow-up-s-line"></i></a>
    <footer class="footer">
    <div class="powered_by">
        
            
            <span id="busuanzi_container_site_pv">
                <i class="ri-eye-fill"></i> <span id="busuanzi_value_site_pv"></span>
            </span></div>
    

    <div class="footer_slogan">
        <span></span>
        <img src="https://likontech.github.io/images/funny.png" height="30px" alt="首先要有意思">
    </div>
</footer>
    <script src="https://likontech.github.io/js/jquery-3.5.1.min.js"></script>
<link href="https://likontech.github.io/css/fancybox.min.css" rel="stylesheet">
<script src="https://likontech.github.io/js/fancybox.min.js"></script>
<script src="https://likontech.github.io/js/zozo.js"></script>


<script type="text/javascript" async
    src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\[\[', '\]\]']],
                processEscapes: true,
                processEnvironments: true,
                skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                TeX: {
                    equationNumbers: { autoNumber: "AMS" },
                    extensions: ["AMSmath.js", "AMSsymbols.js"]
                }
            }
        });

        MathJax.Hub.Queue(function () {
            
            
            
            var all = MathJax.Hub.getAllJax(), i;
            for (i = 0; i < all.length; i += 1) {
                all[i].SourceElement().parentNode.className += ' has-jax';
            }
        });
    </script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: inherit;
        border: inherit;
        color: #515151;
    }
</style>



</body>

</html>